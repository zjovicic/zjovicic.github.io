<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mastermind Game</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #eee;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #00d9ff;
            font-size: clamp(24px, 5vw, 36px);
        }
        
        h2 {
            color: #00d9ff;
            margin-bottom: 15px;
        }
        
        .screen {
            display: none;
        }
        
        .screen.active {
            display: block;
        }
        
        /* Menu styles */
        .menu-btn {
            display: block;
            width: 100%;
            max-width: 400px;
            margin: 15px auto;
            padding: 20px;
            font-size: 18px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            text-align: center;
        }
        
        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 217, 255, 0.3);
        }
        
        .menu-btn small {
            display: block;
            margin-top: 8px;
            opacity: 0.9;
        }
        
        .menu-btn.standard { background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; }
        .menu-btn.advanced { background: linear-gradient(135deg, #FF9800, #E65100); color: white; }
        .menu-btn.worldclass { background: linear-gradient(135deg, #9C27B0, #6A1B9A); color: white; }
        .menu-btn.stats { background: linear-gradient(135deg, #2196F3, #1565C0); color: white; margin-top: 40px; }
        
        /* Game styles */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        .timer {
            font-size: 28px;
            font-weight: bold;
            color: #00d9ff;
            font-family: 'Courier New', monospace;
        }
        
        .game-type-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .game-type-badge.standard { background: #4CAF50; }
        .game-type-badge.advanced { background: #FF9800; }
        .game-type-badge.worldclass { background: #9C27B0; }
        
        .game-info {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #aaa;
        }
        
        .game-info strong {
            color: #00d9ff;
        }
        
        .feedback-legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .feedback-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-peg {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .legend-peg.exact { background: #4CAF50; box-shadow: 0 0 6px rgba(76, 175, 80, 0.6); }
        .legend-peg.misplaced { background: #FF9800; box-shadow: 0 0 6px rgba(255, 152, 0, 0.6); }
        .legend-peg.wrong { background: #444; border: 1px solid #666; }
        
        .attempts-container {
            margin-bottom: 20px;
        }
        
        .attempt-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 12px;
            flex-wrap: wrap;
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
        }
        
        .attempt-number {
            width: 45px;
            font-weight: bold;
            color: #666;
            font-size: 14px;
        }
        
        .guess-display {
            display: flex;
            gap: 6px;
        }
        
        .guess-cell {
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            border-radius: 8px;
            background: #2a2a4a;
            border: 2px solid #444;
            text-transform: uppercase;
        }
        
        .feedback {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }
        
        .feedback-pegs {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-width: 120px;
        }
        
        .feedback-peg {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            transition: transform 0.2s;
        }
        
        .feedback-peg:hover {
            transform: scale(1.2);
        }
        
        .feedback-peg.exact {
            background: radial-gradient(circle at 30% 30%, #6fcf6f, #4CAF50, #2E7D32);
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.7), inset 0 -2px 4px rgba(0,0,0,0.3);
        }
        
        .feedback-peg.misplaced {
            background: radial-gradient(circle at 30% 30%, #ffb74d, #FF9800, #E65100);
            box-shadow: 0 0 8px rgba(255, 152, 0, 0.7), inset 0 -2px 4px rgba(0,0,0,0.3);
        }
        
        .feedback-peg.wrong {
            background: radial-gradient(circle at 30% 30%, #555, #333, #222);
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.5);
            border: 1px solid #444;
        }
        
        .feedback-summary {
            font-size: 12px;
            color: #888;
            min-width: 80px;
            text-align: right;
        }
        
        .feedback-summary .exact-count { color: #4CAF50; font-weight: bold; }
        .feedback-summary .misplaced-count { color: #FF9800; font-weight: bold; }
        
        .current-input-section {
            background: rgba(0, 217, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #00d9ff;
            margin: 20px 0;
        }
        
        .current-input-label {
            font-size: 14px;
            color: #00d9ff;
            margin-bottom: 12px;
        }
        
        .current-input {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .guess-inputs {
            display: flex;
            gap: 6px;
        }
        
        .guess-input {
            width: 42px;
            height: 42px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid #555;
            border-radius: 8px;
            background: #2a2a4a;
            color: white;
            text-transform: uppercase;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        
        .guess-input:focus {
            border-color: #00d9ff;
            outline: none;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.3);
        }
        
        .btn {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-primary { 
            background: linear-gradient(135deg, #00d9ff, #0099cc); 
            color: #1a1a2e; 
        }
        
        .btn-secondary { 
            background: #444; 
            color: white; 
        }
        
        .btn-success { 
            background: linear-gradient(135deg, #4CAF50, #2E7D32); 
            color: white; 
        }
        
        .win-message {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(46, 125, 50, 0.2));
            border: 2px solid #4CAF50;
            border-radius: 15px;
            margin: 20px 0;
        }
        
        .win-message h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }
        
        .win-message p {
            font-size: 18px;
            margin: 10px 0;
        }
        
        .win-message .secret-code {
            font-size: 32px;
            font-family: 'Courier New', monospace;
            color: #4CAF50;
            letter-spacing: 8px;
        }
        
        .win-pegs {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
        }
        
        .win-pegs .feedback-peg {
            width: 24px;
            height: 24px;
            animation: popIn 0.3s ease-out forwards;
        }
        
        @keyframes popIn {
            0% { transform: scale(0); }
            70% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .win-pegs .feedback-peg:nth-child(1) { animation-delay: 0.1s; }
        .win-pegs .feedback-peg:nth-child(2) { animation-delay: 0.2s; }
        .win-pegs .feedback-peg:nth-child(3) { animation-delay: 0.3s; }
        .win-pegs .feedback-peg:nth-child(4) { animation-delay: 0.4s; }
        .win-pegs .feedback-peg:nth-child(5) { animation-delay: 0.5s; }
        .win-pegs .feedback-peg:nth-child(6) { animation-delay: 0.6s; }
        .win-pegs .feedback-peg:nth-child(7) { animation-delay: 0.7s; }
        .win-pegs .feedback-peg:nth-child(8) { animation-delay: 0.8s; }
        
        .win-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
            flex-wrap: wrap;
        }
        
        /* Stats styles */
        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .stats-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            border: 2px solid #444;
            background: transparent;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .tab-btn:hover {
            border-color: #666;
        }
        
        .tab-btn.active {
            border-color: #00d9ff;
            background: rgba(0, 217, 255, 0.15);
            color: #00d9ff;
        }
        
        .personal-bests {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-bottom: 35px;
        }
        
        .best-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 25px 20px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .best-card h3 {
            color: #888;
            font-size: 14px;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .best-card .icon {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .best-card .value {
            font-size: 32px;
            font-weight: bold;
            color: #00d9ff;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .chart-header h3 {
            font-size: 16px;
            color: #ddd;
        }
        
        .chart-canvas {
            width: 100%;
            height: 220px;
            display: block;
        }
        
        .toggle-btn {
            padding: 8px 16px;
            font-size: 13px;
            background: #333;
            border: 1px solid #555;
            color: #aaa;
        }
        
        .toggle-btn.active {
            background: rgba(0, 217, 255, 0.2);
            border-color: #00d9ff;
            color: #00d9ff;
        }
        
        .no-data {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }
        
        .stats-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .btn-danger {
            background: #c0392b;
            color: white;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            font-size: 12px;
            color: #888;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            
            .guess-input, .guess-cell {
                width: 34px;
                height: 34px;
                font-size: 14px;
            }
            
            .attempt-number {
                width: 35px;
                font-size: 12px;
            }
            
            .feedback {
                margin-left: 0;
                width: 100%;
                margin-top: 8px;
                justify-content: flex-start;
            }
            
            .feedback-pegs {
                max-width: none;
            }
            
            .timer {
                font-size: 22px;
            }
            
            .current-input-section {
                padding: 15px;
            }
            
            .btn {
                padding: 10px 18px;
                font-size: 14px;
            }
            
            .feedback-peg {
                width: 14px;
                height: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Menu Screen -->
        <div id="menu-screen" class="screen active">
            <h1>üß† Mastermind</h1>
            <button class="menu-btn standard" onclick="startGame('standard')">
                <strong>Standard</strong>
                <small>6 symbols (1-6) ‚Ä¢ 4 positions</small>
            </button>
            <button class="menu-btn advanced" onclick="startGame('advanced')">
                <strong>Advanced</strong>
                <small>10 symbols (0-9) ‚Ä¢ 6 positions</small>
            </button>
            <button class="menu-btn worldclass" onclick="startGame('worldclass')">
                <strong>World Class</strong>
                <small>14 symbols (0-9, A-D) ‚Ä¢ 8 positions</small>
            </button>
            <button class="menu-btn stats" onclick="showStats()">
                üìä View Statistics
            </button>
        </div>
        
        <!-- Game Screen -->
        <div id="game-screen" class="screen">
            <div class="game-header">
                <button class="btn btn-secondary" onclick="confirmExit()">‚Üê Menu</button>
                <div class="timer" id="timer">00:00</div>
                <span class="game-type-badge" id="game-type-badge"></span>
            </div>
            <div class="game-info" id="game-info"></div>
            <div class="attempts-container" id="attempts-container"></div>
            <div class="current-input-section" id="current-input-section">
                <div class="current-input-label">Attempt #<span id="attempt-number">1</span></div>
                <div class="current-input" id="current-input"></div>
            </div>
            <div id="win-section"></div>
        </div>
        
        <!-- Stats Screen -->
        <div id="stats-screen" class="screen">
            <div class="stats-header">
                <h1>üìä Statistics</h1>
                <button class="btn btn-secondary" onclick="showMenu()">‚Üê Menu</button>
            </div>
            <div class="stats-tabs">
                <button class="tab-btn active" data-tab="standard" onclick="switchStatsTab('standard')">Standard</button>
                <button class="tab-btn" data-tab="advanced" onclick="switchStatsTab('advanced')">Advanced</button>
                <button class="tab-btn" data-tab="worldclass" onclick="switchStatsTab('worldclass')">World Class</button>
            </div>
            <div class="stats-actions">
                <button class="btn btn-danger" onclick="clearStats()">üóëÔ∏è Clear Statistics</button>
            </div>
            <div id="stats-content"></div>
        </div>
    </div>
    
    <script>
        // Game configuration
        const CONFIG = {
            standard: { symbols: '123456', places: 4, name: 'Standard' },
            advanced: { symbols: '0123456789', places: 6, name: 'Advanced' },
            worldclass: { symbols: '0123456789abcd', places: 8, name: 'World Class' }
        };
        
        // Game state
        let currentGame = null;
        let secretCode = '';
        let attempts = [];
        let timerInterval = null;
        let startTime = null;
        let currentStatsTab = 'standard';
        let chartReciprocalStates = {};
        
        // Utility functions
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }
        
        function showMenu() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            showScreen('menu-screen');
        }
        
        function confirmExit() {
            if (attempts.length > 0) {
                if (confirm('Are you sure you want to quit this game? Your progress will be lost.')) {
                    showMenu();
                }
            } else {
                showMenu();
            }
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        function formatTimeVerbose(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            if (mins === 0) return `${secs}s`;
            return `${mins}m ${secs}s`;
        }
        
        // Start game
        function startGame(type) {
            currentGame = type;
            const config = CONFIG[type];
            
            // Generate secret code
            secretCode = '';
            for (let i = 0; i < config.places; i++) {
                secretCode += config.symbols[Math.floor(Math.random() * config.symbols.length)];
            }
            
            console.log('Secret code:', secretCode); // For debugging
            
            attempts = [];
            startTime = Date.now();
            
            // Update UI
            const badge = document.getElementById('game-type-badge');
            badge.textContent = config.name;
            badge.className = 'game-type-badge ' + type;
            
            document.getElementById('game-info').innerHTML = 
                `Crack the <strong>${config.places}-character</strong> secret code using symbols: <strong>${config.symbols.toUpperCase()}</strong>
                <div class="feedback-legend">
                    <div class="feedback-legend-item">
                        <span class="legend-peg exact"></span>
                        <span>Correct position</span>
                    </div>
                    <div class="feedback-legend-item">
                        <span class="legend-peg misplaced"></span>
                        <span>Wrong position</span>
                    </div>
                    <div class="feedback-legend-item">
                        <span class="legend-peg wrong"></span>
                        <span>Not in code</span>
                    </div>
                </div>`;
            
            document.getElementById('attempts-container').innerHTML = '';
            document.getElementById('win-section').innerHTML = '';
            document.getElementById('current-input-section').style.display = 'block';
            document.getElementById('attempt-number').textContent = '1';
            
            createInputRow();
            startTimer();
            showScreen('game-screen');
        }
        
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            updateTimer();
            timerInterval = setInterval(updateTimer, 1000);
        }
        
        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('timer').textContent = formatTime(elapsed);
        }
        
        function createInputRow() {
            const config = CONFIG[currentGame];
            const container = document.getElementById('current-input');
            container.innerHTML = '';
            
            const inputsDiv = document.createElement('div');
            inputsDiv.className = 'guess-inputs';
            
            for (let i = 0; i < config.places; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.maxLength = 1;
                input.className = 'guess-input';
                input.id = `input-${i}`;
                input.setAttribute('autocomplete', 'off');
                input.setAttribute('autocapitalize', 'none');
                input.addEventListener('input', (e) => handleInput(e, i));
                input.addEventListener('keydown', (e) => handleKeydown(e, i));
                input.addEventListener('focus', (e) => e.target.select());
                inputsDiv.appendChild(input);
            }
            
            const submitBtn = document.createElement('button');
            submitBtn.className = 'btn btn-primary';
            submitBtn.textContent = 'Submit';
            submitBtn.onclick = submitGuess;
            
            container.appendChild(inputsDiv);
            container.appendChild(submitBtn);
            
            setTimeout(() => document.getElementById('input-0').focus(), 100);
        }
        
        function handleInput(e, index) {
            const config = CONFIG[currentGame];
            const value = e.target.value.toLowerCase();
            
            // Validate input
            if (value && !config.symbols.includes(value)) {
                e.target.value = '';
                return;
            }
            
            // Move to next input
            if (value && index < config.places - 1) {
                document.getElementById(`input-${index + 1}`).focus();
            }
        }
        
        function handleKeydown(e, index) {
            const config = CONFIG[currentGame];
            
            if (e.key === 'Backspace' && !e.target.value && index > 0) {
                e.preventDefault();
                document.getElementById(`input-${index - 1}`).focus();
            } else if (e.key === 'Enter') {
                submitGuess();
            } else if (e.key === 'ArrowLeft' && index > 0) {
                document.getElementById(`input-${index - 1}`).focus();
            } else if (e.key === 'ArrowRight' && index < config.places - 1) {
                document.getElementById(`input-${index + 1}`).focus();
            }
        }
        
        function submitGuess() {
            const config = CONFIG[currentGame];
            let guess = '';
            
            for (let i = 0; i < config.places; i++) {
                const input = document.getElementById(`input-${i}`);
                guess += input.value.toLowerCase();
            }
            
            if (guess.length !== config.places) {
                // Highlight empty inputs
                for (let i = 0; i < config.places; i++) {
                    const input = document.getElementById(`input-${i}`);
                    if (!input.value) {
                        input.style.borderColor = '#e74c3c';
                        setTimeout(() => input.style.borderColor = '', 1000);
                    }
                }
                return;
            }
            
            // Calculate feedback
            const feedback = calculateFeedback(guess, secretCode);
            attempts.push({ guess, feedback });
            
            // Display attempt
            displayAttempt(attempts.length, guess, feedback);
            
            // Check win
            if (feedback.exactMatch === config.places) {
                gameWon();
            } else {
                // Update attempt number
                document.getElementById('attempt-number').textContent = attempts.length + 1;
                
                // Clear inputs for next attempt
                for (let i = 0; i < config.places; i++) {
                    document.getElementById(`input-${i}`).value = '';
                }
                document.getElementById('input-0').focus();
            }
        }
        
        function calculateFeedback(guess, secret) {
            let exactMatch = 0;  // Correct symbol in correct position
            let symbolMatch = 0; // Correct symbol in wrong position
            
            const guessArr = guess.split('');
            const secretArr = secret.split('');
            const usedGuess = new Array(guess.length).fill(false);
            const usedSecret = new Array(secret.length).fill(false);
            
            // First pass: exact matches (correct position)
            for (let i = 0; i < guess.length; i++) {
                if (guessArr[i] === secretArr[i]) {
                    exactMatch++;
                    usedGuess[i] = true;
                    usedSecret[i] = true;
                }
            }
            
            // Second pass: symbol matches (wrong position)
            for (let i = 0; i < guess.length; i++) {
                if (!usedGuess[i]) {
                    for (let j = 0; j < secret.length; j++) {
                        if (!usedSecret[j] && guessArr[i] === secretArr[j]) {
                            symbolMatch++;
                            usedSecret[j] = true;
                            break;
                        }
                    }
                }
            }
            
            return { 
                exactMatch,      // Correct position
                symbolMatch,     // Wrong position but correct symbol
                totalCorrect: exactMatch + symbolMatch  // Total correct symbols
            };
        }
        
        function createFeedbackPegs(feedback, totalPlaces) {
            const pegsDiv = document.createElement('div');
            pegsDiv.className = 'feedback-pegs';
            
            // Add exact match pegs (green)
            for (let i = 0; i < feedback.exactMatch; i++) {
                const peg = document.createElement('span');
                peg.className = 'feedback-peg exact';
                peg.title = 'Correct position';
                pegsDiv.appendChild(peg);
            }
            
            // Add misplaced pegs (orange)
            for (let i = 0; i < feedback.symbolMatch; i++) {
                const peg = document.createElement('span');
                peg.className = 'feedback-peg misplaced';
                peg.title = 'Wrong position';
                pegsDiv.appendChild(peg);
            }
            
            // Add wrong pegs (dark/empty) for remaining positions
            const wrongCount = totalPlaces - feedback.exactMatch - feedback.symbolMatch;
            for (let i = 0; i < wrongCount; i++) {
                const peg = document.createElement('span');
                peg.className = 'feedback-peg wrong';
                peg.title = 'Not in code';
                pegsDiv.appendChild(peg);
            }
            
            return pegsDiv;
        }
        
        function displayAttempt(num, guess, feedback) {
            const config = CONFIG[currentGame];
            const container = document.getElementById('attempts-container');
            const row = document.createElement('div');
            row.className = 'attempt-row';
            
            const numSpan = document.createElement('span');
            numSpan.className = 'attempt-number';
            numSpan.textContent = `#${num}`;
            
            const guessDiv = document.createElement('div');
            guessDiv.className = 'guess-display';
            
            for (const char of guess) {
                const cell = document.createElement('span');
                cell.className = 'guess-cell';
                cell.textContent = char.toUpperCase();
                guessDiv.appendChild(cell);
            }
            
            const feedbackDiv = document.createElement('div');
            feedbackDiv.className = 'feedback';
            
            // Create colored pegs
            const pegsDiv = createFeedbackPegs(feedback, config.places);
            feedbackDiv.appendChild(pegsDiv);
            
            // Add text summary
            const summarySpan = document.createElement('span');
            summarySpan.className = 'feedback-summary';
            summarySpan.innerHTML = `<span class="exact-count">${feedback.exactMatch}</span> exact, <span class="misplaced-count">${feedback.symbolMatch}</span> close`;
            feedbackDiv.appendChild(summarySpan);
            
            row.appendChild(numSpan);
            row.appendChild(guessDiv);
            row.appendChild(feedbackDiv);
            container.appendChild(row);
            
            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        function gameWon() {
            clearInterval(timerInterval);
            timerInterval = null;
            
            const config = CONFIG[currentGame];
            const timeElapsed = Math.floor((Date.now() - startTime) / 1000);
            const attemptCount = attempts.length;
            
            // Hide input section
            document.getElementById('current-input-section').style.display = 'none';
            
            // Create winning pegs animation
            let winPegsHTML = '<div class="win-pegs">';
            for (let i = 0; i < config.places; i++) {
                winPegsHTML += '<span class="feedback-peg exact"></span>';
            }
            winPegsHTML += '</div>';
            
            // Show win message
            const winSection = document.getElementById('win-section');
            winSection.innerHTML = `
                <div class="win-message">
                    <h2>üéâ Congratulations!</h2>
                    <p>You cracked the code!</p>
                    ${winPegsHTML}
                    <p class="secret-code">${secretCode.toUpperCase()}</p>
                    <p>Attempts: <strong>${attemptCount}</strong> | Time: <strong>${formatTimeVerbose(timeElapsed)}</strong></p>
                    <div class="win-buttons">
                        <button class="btn btn-success" onclick="startGame('${currentGame}')">üîÑ Play Again</button>
                        <button class="btn btn-secondary" onclick="showMenu()">üìã Menu</button>
                        <button class="btn btn-primary" onclick="showStats()">üìä Statistics</button>
                    </div>
                </div>
            `;
            
            // Save stats
            saveGameStats(currentGame, attemptCount, timeElapsed);
        }
        
        // Stats management
        function saveGameStats(gameType, attemptCount, time) {
            const stats = getStats();
            
            if (!stats[gameType]) {
                stats[gameType] = {
                    games: [],
                    bestTime: null,
                    bestAttempts: null
                };
            }
            
            const date = new Date().toISOString().split('T')[0];
            stats[gameType].games.push({ 
                attempts: attemptCount, 
                time, 
                date, 
                timestamp: Date.now() 
            });
            
            // Update bests
            if (stats[gameType].bestTime === null || time < stats[gameType].bestTime) {
                stats[gameType].bestTime = time;
            }
            if (stats[gameType].bestAttempts === null || attemptCount < stats[gameType].bestAttempts) {
                stats[gameType].bestAttempts = attemptCount;
            }
            
            localStorage.setItem('mastermind-stats', JSON.stringify(stats));
        }
        
        function getStats() {
            try {
                const stored = localStorage.getItem('mastermind-stats');
                return stored ? JSON.parse(stored) : {};
            } catch (e) {
                return {};
            }
        }
        
        function clearStats() {
            if (confirm('Are you sure you want to clear ALL statistics? This cannot be undone.')) {
                localStorage.removeItem('mastermind-stats');
                chartReciprocalStates = {};
                renderStats(currentStatsTab);
            }
        }
        
        // Stats display
        function showStats() {
            showScreen('stats-screen');
            updateTabButtons();
            renderStats(currentStatsTab);
        }
        
        function updateTabButtons() {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === currentStatsTab);
            });
        }
        
        function switchStatsTab(tab) {
            currentStatsTab = tab;
            updateTabButtons();
            renderStats(tab);
        }
        
        function renderStats(gameType) {
            const stats = getStats();
            const gameStats = stats[gameType] || { games: [], bestTime: null, bestAttempts: null };
            const config = CONFIG[gameType];
            
            const content = document.getElementById('stats-content');
            
            if (gameStats.games.length === 0) {
                content.innerHTML = `
                    <div class="no-data">
                        <h3>No games played yet</h3>
                        <p>Play some ${config.name} games to see your statistics!</p>
                        <button class="btn btn-primary" onclick="startGame('${gameType}')" style="margin-top: 20px;">
                            Play ${config.name}
                        </button>
                    </div>
                `;
                return;
            }
            
            // Calculate averages
            const totalAttempts = gameStats.games.reduce((sum, g) => sum + g.attempts, 0);
            const totalTime = gameStats.games.reduce((sum, g) => sum + g.time, 0);
            const avgAttempts = (totalAttempts / gameStats.games.length).toFixed(1);
            const avgTime = Math.round(totalTime / gameStats.games.length);
            
            content.innerHTML = `
                <div class="personal-bests">
                    <div class="best-card">
                        <div class="icon">‚ö°</div>
                        <h3>Best Time</h3>
                        <div class="value">${formatTimeVerbose(gameStats.bestTime)}</div>
                    </div>
                    <div class="best-card">
                        <div class="icon">üéØ</div>
                        <h3>Fewest Attempts</h3>
                        <div class="value">${gameStats.bestAttempts}</div>
                    </div>
                    <div class="best-card">
                        <div class="icon">üìä</div>
                        <h3>Games Played</h3>
                        <div class="value">${gameStats.games.length}</div>
                    </div>
                    <div class="best-card">
                        <div class="icon">üìà</div>
                        <h3>Avg Attempts</h3>
                        <div class="value">${avgAttempts}</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div class="chart-header">
                        <h3>üìà Attempts per Game</h3>
                        <button class="btn toggle-btn ${chartReciprocalStates['chart1'] ? 'active' : ''}" 
                                onclick="toggleReciprocal('chart1')">
                            ${chartReciprocalStates['chart1'] ? '1/x ON' : '1/x OFF'}
                        </button>
                    </div>
                    <canvas id="chart1" class="chart-canvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-dot" style="background: #00d9ff;"></div>
                            <span>${chartReciprocalStates['chart1'] ? '1/Attempts (higher = better)' : 'Attempts (lower = better)'}</span>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div class="chart-header">
                        <h3>‚è±Ô∏è Time per Game (seconds)</h3>
                        <button class="btn toggle-btn ${chartReciprocalStates['chart2'] ? 'active' : ''}" 
                                onclick="toggleReciprocal('chart2')">
                            ${chartReciprocalStates['chart2'] ? '1/x ON' : '1/x OFF'}
                        </button>
                    </div>
                    <canvas id="chart2" class="chart-canvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-dot" style="background: #4CAF50;"></div>
                            <span>${chartReciprocalStates['chart2'] ? '1/Time (higher = better)' : 'Time (lower = better)'}</span>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div class="chart-header">
                        <h3>üìÖ Average Attempts by Date</h3>
                        <button class="btn toggle-btn ${chartReciprocalStates['chart3'] ? 'active' : ''}" 
                                onclick="toggleReciprocal('chart3')">
                            ${chartReciprocalStates['chart3'] ? '1/x ON' : '1/x OFF'}
                        </button>
                    </div>
                    <canvas id="chart3" class="chart-canvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-dot" style="background: #FF9800;"></div>
                            <span>${chartReciprocalStates['chart3'] ? '1/Avg Attempts (higher = better)' : 'Avg Attempts (lower = better)'}</span>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <div class="chart-header">
                        <h3>üìÖ Average Time by Date (seconds)</h3>
                        <button class="btn toggle-btn ${chartReciprocalStates['chart4'] ? 'active' : ''}" 
                                onclick="toggleReciprocal('chart4')">
                            ${chartReciprocalStates['chart4'] ? '1/x ON' : '1/x OFF'}
                        </button>
                    </div>
                    <canvas id="chart4" class="chart-canvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-dot" style="background: #9C27B0;"></div>
                            <span>${chartReciprocalStates['chart4'] ? '1/Avg Time (higher = better)' : 'Avg Time (lower = better)'}</span>
                        </div>
                    </div>
                </div>
            `;
            
            // Draw charts
            setTimeout(() => {
                // Chart 1: Attempts per game
                const attemptsData = gameStats.games.map((g, i) => ({ 
                    x: i + 1, 
                    y: g.attempts,
                    label: `Game ${i + 1}`
                }));
                drawChart('chart1', attemptsData, 'Game #', 'Attempts', '#00d9ff');
                
                // Chart 2: Time per game
                const timeData = gameStats.games.map((g, i) => ({ 
                    x: i + 1, 
                    y: g.time,
                    label: `Game ${i + 1}`
                }));
                drawChart('chart2', timeData, 'Game #', 'Time (s)', '#4CAF50');
                
                // Calculate daily averages
                const dailyData = {};
                gameStats.games.forEach(g => {
                    if (!dailyData[g.date]) {
                        dailyData[g.date] = { attempts: 0, time: 0, count: 0 };
                    }
                    dailyData[g.date].attempts += g.attempts;
                    dailyData[g.date].time += g.time;
                    dailyData[g.date].count++;
                });
                
                const dates = Object.keys(dailyData).sort();
                
                // Chart 3: Average attempts by date
                const avgAttemptsData = dates.map((d, i) => ({
                    x: i + 1,
                    y: dailyData[d].attempts / dailyData[d].count,
                    label: d
                }));
                drawChart('chart3', avgAttemptsData, 'Date', 'Avg Attempts', '#FF9800', dates);
                
                // Chart 4: Average time by date
                const avgTimeData = dates.map((d, i) => ({
                    x: i + 1,
                    y: dailyData[d].time / dailyData[d].count,
                    label: d
                }));
                drawChart('chart4', avgTimeData, 'Date', 'Avg Time (s)', '#9C27B0', dates);
            }, 50);
        }
        
        function toggleReciprocal(chartId) {
            chartReciprocalStates[chartId] = !chartReciprocalStates[chartId];
            renderStats(currentStatsTab);
        }
        
        function drawChart(canvasId, data, xLabel, yLabel, color, dateLabels = null) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || data.length === 0) return;
            
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { top: 30, right: 30, bottom: 50, left: 60 };
            
            // Apply reciprocal if toggled
            const useReciprocal = chartReciprocalStates[canvasId];
            let processedData = data.map(d => ({
                ...d,
                y: useReciprocal ? (d.y > 0 ? 1 / d.y : 0) : d.y
            }));
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            const maxY = Math.max(...processedData.map(d => d.y)) * 1.15 || 1;
            const minY = 0;
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridLines = 5;
            for (let i = 0; i <= gridLines; i++) {
                const y = padding.top + (i / gridLines) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();
            
            // Draw Y axis labels
            ctx.fillStyle = '#888';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            for (let i = 0; i <= gridLines; i++) {
                const value = maxY - (i / gridLines) * (maxY - minY);
                const y = padding.top + (i / gridLines) * chartHeight;
                ctx.fillText(value.toFixed(useReciprocal ? 3 : 1), padding.left - 8, y);
            }
            
            // Draw Y axis label
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(useReciprocal ? `1/${yLabel}` : yLabel, 0, 0);
            ctx.restore();
            
            // Draw X axis label
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(xLabel, width / 2, height - 15);
            
            // Draw X axis labels (limited number)
            const maxLabels = Math.min(processedData.length, 10);
            const step = Math.ceil(processedData.length / maxLabels);
            
            ctx.textBaseline = 'top';
            for (let i = 0; i < processedData.length; i += step) {
                const x = padding.left + ((i) / Math.max(processedData.length - 1, 1)) * chartWidth;
                const label = dateLabels ? dateLabels[i].slice(5) : (i + 1).toString();
                ctx.fillText(label, x, height - padding.bottom + 8);
            }
            
            // Draw line
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.beginPath();
            
            processedData.forEach((point, i) => {
                const x = padding.left + (i / Math.max(processedData.length - 1, 1)) * chartWidth;
                const y = padding.top + ((maxY - point.y) / (maxY - minY)) * chartHeight;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            
            ctx.stroke();
            
            // Draw area under line
            ctx.lineTo(padding.left + chartWidth, height - padding.bottom);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.closePath();
            ctx.fillStyle = color.replace(')', ', 0.1)').replace('rgb', 'rgba');
            ctx.fill();
            
            // Draw points
            ctx.fillStyle = color;
            processedData.forEach((point, i) => {
                const x = padding.left + (i / Math.max(processedData.length - 1, 1)) * chartWidth;
                const y = padding.top + ((maxY - point.y) / (maxY - minY)) * chartHeight;
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // White inner circle
                ctx.fillStyle = '#1a1a2e';
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = color;
            });
        }
        
        // Handle window resize for charts
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (document.getElementById('stats-screen').classList.contains('active')) {
                    renderStats(currentStatsTab);
                }
            }, 250);
        });
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            showScreen('menu-screen');
        });
    </script>
</body>
</html>
